import os
import traceback
import itertools
import click
import json
from pinecone_client import find_limit_vector_query
from interactive_data_pair_membership_scorer import InteractiveDataPairMembershipScorer
from embed_cache import EmbedArrayCache

BAREFOOT_CONTESSA_JSON = 'open_ai/data/barefootcontessa_array.json'
OH_SHE_GLOWS_JSON = 'open_ai/data/ohsheglows_array.json'

"""
This provides a command line programe so that a user can interactively score ingredients
as 0 or 1 vs matches generated by an OOB hugging face sentance transformer.

press 0 or enter to score a match as 0
press 1 to score as 1
press d to prematurely end scoring of the query
"""
class IngredientScorer(InteractiveDataPairMembershipScorer):
    def __init__(self, recipes, outpath, cache_outpath):
        super().__init__(
            EmbedArrayCache(data=[], outpath=cache_outpath, should_hydrate=True),
            self._get_query_data,
            self._get_matches,
            self._out
        )
        self.outpath = outpath
        self.recipes = recipes

    def run(self):
        super().run()

    def _get_query_data(self):
        """
        returns an iterator of query data
        """

        for recipe in self.recipes:
            ingredient_names = [i["name"] for i in recipe["ingredients_w_units"]]
            for name in ingredient_names:
                yield name

    def _get_matches(self, query):
        """
        gets an iterator of potential matches for the query 
        """
        food_matches = find_limit_vector_query(query, 15, 'info')

        for match in food_matches:
            match_name = match['metadata']['tmp_name']
            yield match_name

    def _out(self, scored_data):
        """
        saves the scored data
        """
        (name, match_name, score) = scored_data

        with open(self.outpath, 'a') as f:
            f.write(json.dumps({
                "query": name,
                "match": match_name,
                "score": score,
            }) + "\n")

class AutoVeganIngredientScorer:
    def __init__(self, outpath):
        self.outpath = outpath

    def run(self):
        vegan_identifiers = ['substitute', 'vegetarian', 'vegan', 'veggie', 'veg', 'veggie based', 'vegetable based',
                             'dairy-free', 'dairy free', 'non-dairy', 'non dairy', 
                             'meat-free', 'meat free', 'meatless', 'no meat', 'soy', 'soy protein', 'soy based', 'cashew based', 'almond based', 'pea based', 'tofu based',
                             'almond', 'almond protein', 'cashew', 'cashew protein', 'pea protein', 'pea', 'tofu', 'seitan based',
                             'seitan', 'vegetable protein', 'tofurkey']
        meat_substitute_items = ['cream', 'creamer', 'butter', 'cheese', 'milk', 'eggs', 'meat', 'burger', 'patty', 'patties', 'sausage', 'chicken', 'turkey', 'beef']

        for sub in meat_substitute_items:
            for id1 in vegan_identifiers:
                vegan_food_1 = f"{id1} {sub}"
                self._out((vegan_food_1, sub, 0))

                for id2 in vegan_identifiers:
                    vegan_food_2 = f"{id2} {sub}"

                    self._out((vegan_food_1, vegan_food_2, 1))

    def _out(self, scored_data):
        """
        saves the scored data
        """
        (name, match_name, score) = scored_data

        with open(self.outpath, 'a') as f:
            f.write(json.dumps({
                "query": name,
                "match": match_name,
                "score": score,
            }) + "\n")

@click.command()
@click.option('--auto', is_flag=True, default=False)
@click.option('--inpaths', '-i', multiple=True, default=[BAREFOOT_CONTESSA_JSON, OH_SHE_GLOWS_JSON])
@click.option('--outpath', '-o', type=str, default='open_ai/data')
@click.option('--cache_outpath', '-co', type=str)
def main(auto, inpaths, outpath, cache_outpath = None):

    if auto:
        try:
            AutoVeganIngredientScorer(outpath).run()
        except Exception as e:
            traceback.print_exc()
            print(f"Failed to score recipees: {e}")
    else:
        all_recipes = []
        for inpath in inpaths:
            with open(inpath, 'r') as file:
                recipes = json.loads(file.read())
                all_recipes += recipes

        scorer = IngredientScorer(all_recipes, outpath, cache_outpath)

        try:
            scorer.run()
        except Exception as e:
            traceback.print_exc()
            print(f"Failed to score recipees: {e}")
            scorer.cache.backup()

if __name__ == "__main__":
    main()
