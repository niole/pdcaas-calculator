import os
import traceback
import itertools
import click
import json
from pinecone_client import find_limit_vector_query
from interactive_data_pair_membership_scorer import InteractiveDataPairMembershipScorer
from embed_cache import EmbedArrayCache

BAREFOOT_CONTESSA_JSON = 'open_ai/data/barefootcontessa_array.json'
OH_SHE_GLOWS_JSON = 'open_ai/data/ohsheglows_array.json'

"""
This provides a command line programe so that a user can interactively score ingredients
as 0 or 1 vs matches generated by an OOB hugging face sentance transformer.

press 0 or enter to score a match as 0
press 1 to score as 1
press d to prematurely end scoring of the query
"""
class IngredientScorer(InteractiveDataPairMembershipScorer):
    def __init__(self, recipes, outpath, cache_outpath):
        super().__init__(
            EmbedArrayCache(data=[], outpath=cache_outpath, should_hydrate=True),
            self._get_query_data,
            self._get_matches,
            self._out
        )
        self.outpath = outpath
        self.recipes = recipes

    def run(self):
        super().run()

    def _get_query_data(self):
        """
        returns an iterator of query data
        """

        for recipe in self.recipes:
            ingredient_names = [i["name"] for i in recipe["ingredients_w_units"]]
            for name in ingredient_names:
                yield name

    def _get_matches(self, query):
        """
        gets an iterator of potential matches for the query 
        """
        food_matches = find_limit_vector_query(query, 15, 'info')

        for match in food_matches:
            match_name = match['metadata']['tmp_name']
            yield match_name

    def _out(self, scored_data):
        """
        saves the scored data
        """
        (name, match_name, score) = scored_data

        with open(self.outpath, 'a') as f:
            f.write(json.dumps({
                "name": name,
                "match": match_name,
                "label": score,
            }) + "\n")

@click.command()
@click.option('--inpaths', '-i', multiple=True, default=[BAREFOOT_CONTESSA_JSON, OH_SHE_GLOWS_JSON])
@click.option('--outpath', '-o', type=str, default='open_ai/data')
@click.option('--cache_outpath', '-co', type=str)
def main(inpaths, outpath, cache_outpath = None):

    if not os.path.isdir(outpath):
        raise Exception(f'{outpath} is not a directory')

    outpath = f'{outpath}/training_data.json'

    all_recipes = []
    for inpath in inpaths:
        with open(inpath, 'r') as file:
            recipes = json.loads(file.read())
            all_recipes += recipes

    scorer = IngredientScorer(all_recipes, outpath, cache_outpath)

    try:
        scorer.run()
    except Exception as e:
        traceback.print_exc()
        print(f"Failed to score recipees: {e}")
        scorer.cache.backup()

if __name__ == "__main__":
    main()
